## 面向对象
封装: 组织外部代码直接操作对象来控制访问内部细节的技术.只能通过公共的接口与对象进行交互,将外部代码与对象内部的运行细节隔离开来.
继承
多态

### set,get,__defineGetter__,__defineSetter__,defineProperty

### 设计模式

#### 工厂模式
工厂模式允许我们将对象的创建从实现中离出来. 从本质上说, 一个工厂方法包含了一个新实例的创建.   
工厂模式的使用者对实例是如何被创建丝毫不知情.

**私有属性**
其实是在构造函数内, 通过一个对象privateProperties来保存属性, 不要使用this.属性 = 值,要通过set属性(值), get属性()来设置或获取属性的值, 真正获取属性就要去privateProperties对象里面找对应的属性. `class Person{}`,  `function Person(){}`,  `function createPerson(){}` 都可以实现私有属性.

**可组合的工厂函数**
可组合的工厂函数是一类特殊的工厂函数, 他们可以被组合到一起来构建新的增强的工厂函数.
什么时候用?
当我们想要创建从多个源继承一些属性和方法的对象, 却不想创建复杂的类时, 使用可组合的工厂函数.

####the-revaling-constructor-pattern
揭示构造函数

```
new promise((resolve, reject) => {

});
```
####只读事件触发器
在揭示够高函数的基础上, 构建一个只读事件触发器
这是一种特殊的事件触发器, 它无法调用

#### 代理模式
proxy是一个用来控制对另一个对象(本体)访问的对象.
实现的与本体相同的接口, 我们可以对这两个对象进行随意的替换使用.
也叫替代模式.
可以拦截所有或部分对本体对象执行的操作, 补充或增强他们的行为.

ES6有Proxy类.

**代理模式的主要使用场景**

1. 数据验证(Data validation):
2. 安全性(Security)
3. 缓存(Caching)
4. 延迟初始化(Lazy initialization)
5. 日志(logging)
6. 远程对象代理(Remote objects)




