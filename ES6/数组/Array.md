### Array

#### Array.of,Array.from, ...的对比
<style>
table th:first-of-type {
    width: 120px;
}
table th:last-of-type{
    colspan:
}
</style>
| 数组扩展 | 含义 | 用法实例  |
| ---- | --- | --- |
| Array.of | 返回一个数组.将每个参数作为数组中的元素. |  |
| Array.from  | 返回一个数组.数组成员是第一个参数的value值. 3个参数,第一个参数: 类数组对象或实现了Iterator接口的对象;第二个参数: 类似数组的map函数,用来对每个元素进行处理，将处理后的值放入返回的数组;第三个参数:用来绑定this. |  |
| ... | 返回一个数组.将一个数组转为用逗号分隔的参数序列.扩展运算符后面接数组或者实现Iterator接口的对象.  |  |

#### 找元素
 find() , findIndex(), includes(), filter()
 
| 方法 | 含义 | 实例 |
| --- | --- | --- |
| find() | 返回数组中的元素.参数是回调函数,回调函数的参数是元素, 回调函数返回true,则说明找到符合条件的元素,返回该元素, 如果没有找到符合条件的元素则返回undefined. |  |
| findeIndex() | 返回元素的索引.与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1. |  |
| includes() | 返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。 indexOf方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相等运算符（===）进行判断，这会导致对NaN的误判.
| filter() | 返回一个数组.参数是回调函数, 回调函数的参数是数组元素, 返回所有满足条件的元素, 如果没有,则返回空数组 |  |

#### 扩展运算符

**含义:**
扩展运算符（spread）是三个点（...）。它好比 rest 参数的逆运算，
**将一个数组(或者实现了iterator遍历器的对象)转为用逗号分隔的参数序列**。
    1. 这个可以作为函数的参数(就成了逗号隔开的参数序列: fn(1,2,3,4) <===> fn(...[1, 2, 3, 4]))   
    2. 函数在定义时候, 也可以使用扩展运算符定义参数. 这时候与上面的作用是相反的(逆运算, 有点像扩展运算符的解构赋值)
**替代函数的 apply 方法**

**主要应用:**
1. 将字符串转真正数组
2. 与解构赋值结合
    扩展运算符必须是位于最后一个变量.
    下面的a3就是解构赋值
3. 合并数组
    注意写法:
    `const a1 = [1, 2, 3];
     const a2 = [...a1]; // [1, 2, 3]
     const [...a3] = a1; // [1, 2, 3]` 效果都一样
4. 复制数组
5. 把实现了 Iterator 接口的对象转成真正的数组
    `[...map]`, `[...set]`等
**内部原理:**
扩展运算符内部调用的是数据结构的 Iterator 接口,因此只要具有 Iterator 接口的对象，都可以使用扩展运算符
Map 和 Set 结构，Generator 函数

